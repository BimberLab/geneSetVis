---
title: "cerebro_test2"
output: html_document
---

##set-up
```{r}
library(shiny)
library(shinydashboard)
library(flexdashboard)

library(dplyr)
library(ggplot2)
library(tidyr)
library(reshape2)
library(stringr)
library(readxl) 
library(datapasta)
library(plotly)
library(cowplot)
library(kableExtra)
library(DT)
library(formattable)
library(gridExtra)
library(grid)
library(Matrix)

library(testthat)

library(Seurat)
library(OOSAP)

library(org.Hs.eg.db)
library(AnnotationHub)
library(ReactomePA)
library(clusterProfiler)
library(fgsea) 

library(biomaRt)
library(STRINGdb) 
library(RDAVIDWebService) 
library(msigdbr)


```

```{r}
BiocManager::install("romanhaa/cerebroApp")
library(cerebroApp)
cerebroApp::launchCerebro()


```


##data
```{r}
DEtable <- readRDS("./testdata/cbndObj02_x7.res02.markers.rds")

seurat <- readRDS("./zikvObj_02.seurat.rds")

DEtable <- DEtable[1:618,]
```

```{r}
#zikv$cells <- c(1)
cerebroApp::exportFromSeurat(object = zikv, assay = "RNA", file = "/Users/onwuzu/Downloads/zikvObj_02.seurat.cerebro.crb", column_sample = "Barcode", column_cluster = "ClusterNames_0.2", column_nUMI = "nFeature_RNA", column_nGene = "nCount_RNA", experiment_name = "zikv02", organism = "human")

```


```{r}
DEtable_subset <- filter(DEtable, cluster == "0" | cluster == "1")

```


##runs
```{r}
string_results <- runSTRINGdb(DEtable = DEtable_subset, numHits = 200, refSpeciesNum = 9606)
saveRDS(string_results, "cbndObj02_x7.res02.markers_string_result.rds")

string_results <- readRDS("cbndObj02_x7.res02.markers_string_result.rds")

```

```{r}
msig_results <- runMSigDB(DEtable = DEtable_subset, species = "Homo sapiens")
saveRDS(msig_results, "cbndObj02_x7.res02.markers_msig_result.rds")
#msig_results

```





```{r}
#################################################################################################################
  #################################################################################################################
  # output$fgsea_cpplots_select_cluster_dotplot_plot <- renderPlot({
  #   extract <- paste(input$msigdbr_select_cluster_input, "fgsea_results", sep = "_")
  #   extract_2 <- paste(input$msigdbr_select_cluster_input, "input_genes", sep = "_")
  #   e <- as.enrichResult(result = msig_results[[extract]], inputIds = msig_results[[extract_2]])
  #   enrichplot::dotplot(e)
  # })
  # 
  # 
  # output$fgsea_cpplots_select_cluster_emapplot_plot <- renderPlot({
  #   extract <- paste(input$msigdbr_select_cluster_input, "fgsea_results", sep = "_")
  #   extract_2 <- paste(input$msigdbr_select_cluster_input, "input_genes", sep = "_")
  #   e <- as.enrichResult(result = msig_results[[extract]], inputIds = msig_results[[extract_2]])
  #   enrichplot::emapplot(e)
  # })
  # 
  # 
  # output$fgsea_cpplots_select_cluster_cnetplot_plot <- renderPlot({
  #   extract <- paste(input$msigdbr_select_cluster_input, "fgsea_results", sep = "_")
  #   extract_2 <- paste(input$msigdbr_select_cluster_input, "input_genes", sep = "_")
  #   e <- as.enrichResult(result = msig_results[[extract]], inputIds = msig_results[[extract_2]])
  #   enrichplot::cnetplot(e)
  # })
  # 
  # 
  # output$fgsea_cpplots_select_cluster_upsetplot_plot <- renderPlot({
  #   extract <- paste(input$msigdbr_select_cluster_input, "fgsea_results", sep = "_")
  #   extract_2 <- paste(input$msigdbr_select_cluster_input, "input_genes", sep = "_")
  #   e <- as.enrichResult(result = msig_results[[extract]], inputIds = msig_results[[extract_2]])
  #   enrichplot::upsetplot(e)
  # })
  # 
  # 
  # output$fgsea_cpplots_select_cluster_heatplot_plot <- renderPlot({
  #   extract <- paste(input$msigdbr_select_cluster_input, "fgsea_results", sep = "_")
  #   extract_2 <- paste(input$msigdbr_select_cluster_input, "input_genes", sep = "_")
  #   e <- as.enrichResult(result = msig_results[[extract]], inputIds = msig_results[[extract_2]])
  #   enrichplot::heatplot(e)
  # })
  
  #x <- makePlotSet(outputKey = 'fgsea', enrichTypeResList = msig_results, selectedCluster = 0)
  
  #makePlotSet2(output = output, outputKey = 'fgsea', enrichTypeResList = msig_results, selectedCluster = 0)
  #selectedCluster <- reactive({input$msigdbr_select_cluster_input})
  #selectedCluster <- print(selectedCluster())
```





###stringdb
```{r}

GO_hits <- function(GO_term, hits){
  string_db <- STRINGdb$new(version="10", species=refSpeciesNum, score_threshold=0, input_directory="")
  go_term_prot <- string_db$get_term_proteins(GO_term)
  #go_term_prot <- string_db$get_term_proteins("GO:0042981")
  go_term_prot <- go_term_prot[go_term_prot$STRING_id %in% hits,]
  hits_in_term <- go_term_prot$preferred_name
  return(as.character(hits_in_term))
}


```


###msig
```{r}


##--
#entrezIDs <- mapIds(org.Hs.eg.db, as.character(allMarkers), 'ENTREZID', 'SYMBOL')

#colnames(human.msig)
fgsea_results$Enrichment = ifelse(fgsea_results$ES > 0, "Up-regulated", "Down-regulated")
g = ggplot(fgsea_results[1:20, ], aes(reorder(pathway, ES), ES)) +
  geom_segment( aes(reorder(pathway, ES), xend=pathway, y=0, yend=ES)) +
  geom_point( size=5, aes( fill = Enrichment),
              shape=21, stroke=2) +
  scale_fill_manual(values = c("Down-regulated" = "dodgerblue",
                      "Up-regulated" = "firebrick") ) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
         title="GSEA - Biological Processes") + 
  theme_minimal()

plotly::ggplotly(g)


as(y, "enrichResult")

saveRDS(y, "fgsea_res.rds")
```

```{r}
e <- as.enrichResult(result = msig_results$`1_fgsea_results`, inputIds = msig_results$`1_input_genes`)




dotplot(e,
  x = "Count",
  color = "p.adjust",
  showCategory = 30,
  size = NULL,
  split = NULL,
  font.size = 12,
  title = "", orderBy="x", decreasing=F)+
      scale_y_discrete(labels = function(x) stringr::str_wrap(str_replace_all(x, "pattern_" , "_"), width = 40))

#rownames(e@result) <- result$Description
plotly::ggplotly(enrichplot::emapplot(e))

plotly::ggplotly(enrichplot::cnetplot(e))

plotly::ggplotly(enrichplot::heatplot(e))

#install.packages("ggupset")
#library(ggupset)
plotly::ggplotly(enrichplot::upsetplot(e))
plotly::ggplotly(enrichplot::upsetplot(e))

```

##debug
```{r}
obj <- DOSE:::get_enriched(d)





gseaplot(fgsea_results)
gseaplot2()



function (x, n) 
{
  n <- enrichplot:::update_n(e, showCategory = 30)
  geneSets <- geneInCategory(e)
  y <- as.data.frame(e)
  geneSets <- geneSets[y$ID]
  names(geneSets) <- y$Description
  if (is.numeric(n)) {
    return(geneSets[1:n])
  }
  return(geneSets[n])
}




geneSets <- enrichplot:::extract_geneSets(e, n)
geneSets <- geneInCategory(e)
y <- as.data.frame(e)
geneSets <- geneSets[y$ID]
names(geneSets) <- y$Description
if (is.numeric(n)) {
return(geneSets[1:n])
}
return(geneSets[n])

foldChange <- fc_readable(x, foldChange)
d <- list2df(geneSets)

if (!is.null(foldChange)) {
    d$foldChange <- foldChange[as.character(d[,2])]
}
        
        


dotplot(msig_enricher, x = "Count")

p <- enrichPathway(entrezID)

entrezID <- mapIds(org.Hs.eg.db, as.character(clusterTable$gene), 'ENTREZID', 'SYMBOL')

d <- enrichDO(entrezID, pvalueCutoff = 0.1)

g <- enrichGO(entrezID, 'org.Hs.eg.db', ont="BP", pvalueCutoff=0.01, readable = T)

enrichplot::dotplot(d, showCategory=100)
enrichplot::dotplot(d, showCategory=59)

enrichplot::dotplot(y)

enrichplot::dotplot(y)

f <- ggplot2::fortify(d,)

enrichplot::dotplot(d)

geneSets <- ""
geneSetsOI <- geneSets[c(y@result$Description)]
genesInGeneSet <- lapply(geneSetsOI, intersect, y=gene)
genesInGeneSet.stack <- stack(genesInGeneSet) %>% rename(ind = "pathway") %>% group_by(pathway) %>% summarise(geneID = paste(values, collapse = "/"))
fgsea_results <- merge(fgsea_results, genesInGeneSet.stack, by = "pathway")

as(fgsea_results, "enrichResult")

d@result <- y@result
```



##shinyApp
```{r}


##----------------------------------------------------------------------------##
## ShinyApp
##----------------------------------------------------------------------------##
## Borrowed ideas from cerebroApp :
##https://github.com/romanhaa/cerebroApp

shinyApp(
  ui = dashboardPage(
    dashboardHeader(
      title = span("GeneSetVis", style = "color: white; font-size: 28px; font-weight: bold")
    ),
    dashboardSidebar(tags$head(tags$style(
      HTML(".content-wrapper {overflow-x: scroll;}")
    )),
    sidebarMenu(sidebarMenuOutput("sidebar_menu"))),
    dashboardBody(
      tags$script(HTML('$("body").addClass("fixed");')),
      tabItems(tab_load_data,
               tab_stringdb,
               tab_msigdbr, 
               tab_clusterprofiler)
    )
  ),
  
  ##--------------------------------------------------------------------------##
  ## Server
  ##--------------------------------------------------------------------------##
  server = function(input, output, session) {
    
    preferences <- reactiveValues(use_webgl = TRUE)
    
    ##---------------------------------------------##
    ## Sidebar menu
    ##---------------------------------------------##
    output$sidebar_menu <- renderMenu({
      sidebarMenu(
        id = "sidebar",
        menuItem(
          text = "Load data",
          tabName = "loadData",
          icon = icon(NULL),
          selected = TRUE
        ),
        menuItem(
          text = "STRINGdb",
          tabName = "stringdb",
          icon = icon(NULL),
          selected = TRUE
        ),
        menuItem(
          text = "MsigDB",
          tabName = "msigdbr",
          icon = icon(NULL)
        ), 
        menuItem(
          text = "clusterProfiler",
          tabName = "clusterprofiler",
          icon = icon(NULL)
        )
      )
    })

    ##-------------------##
    ## Sample data
    ##-------------------##
    sample_data <- reactive({
      if (is.null(input$input_file) ||
          is.na(input$input_file)) {
        data_rds_path <- "./testdata/cbndObj02_x7.res02.markers.rds"
        sample_data <- readRDS(data_rds_path)
        
      } else {
        req(input$input_file)
        sample_data <- readRDS(input$input_file)
        data_rds_path <- input$input_file
      }
      
      data_basename <- basename(data_rds_path) %>% tools::file_path_sans_ext()
      
      string_result_rds_name <- paste(data_basename, "string", "result", sep = "_")
      msig_result_rds_name <- paste(data_basename, "msig", "result", sep = "_")
      
      if (!file.exists(paste(string_result_rds_name, ".rds", sep = ""))){
        string_results <- runSTRINGdb(DEtable = sample_data, refSpeciesNum = 9606)
        saveRDS(string_results, paste(string_result_rds_name, ".rds", sep = ""))
      } else {
        string_results <- readRDS(paste(string_result_rds_name, ".rds", sep = ""))
      }
      
      if (!file.exists(paste(msig_result_rds_name, ".rds", sep = ""))){
        msig_results <- runMSigDB(DEtable = sample_data, species = "Homo sapiens")
        saveRDS(msig_results, paste(msig_result_rds_name, ".rds", sep = ""))
      } else {
        msig_results <- readRDS(paste(msig_result_rds_name, ".rds", sep = ""))
      }

      # get list of cluster names
      # if (is.factor(sample_data$cluster)) {
      #   sample_data$cluster_names <- levels(sample_data$cluster)
      # } else {
      #   sample_data$cluster_names <-
      #     sample_data$cluster %>% unique() %>% sort()
      # }
      sample_data
    })
    
   
    
    ##--------------------##
    ## Tabs - server.R
    ##--------------------##
    
    output$runstringdb_select_parameters <- renderUI({
        stringdbSpecies <- STRINGdb::get_STRING_species(version = "10")
        fluidRow(
          selectInput(
            inputId = "stringdb_refSpecies_input",
            label = "Reference species:",
            selected = "Homo sapiens",
            choices = stringdbSpecies$compact_name
          ),
          numericInput(
            inputId = "stringdb_maxHitsToPlot_input",
            label = "Max. number of hits to plot:",
            value = 200
          ), 
          numericInput(
            inputId = "stringdb_scoreThreshold_input",
            label = "Score threshold:",
            value = 0
          ), 
          textInput(
            inputId = "stringdb_runname",
            label = "Run name:",
            placeholder = "Run1"
                
          )
        )
    })
    
    #species.msig <- msigdbr::msigdbr(species = input$msigdbr_species_input)
    #subcategory <- filter(species.msig, species.msig$gs_cat == input$msigdbr_category_input)
    output$runmsigdbr_select_parameters <- renderUI({
        msigdbrSpecies <- data.frame(Species = msigdbr::msigdbr_show_species())
        species.msig <- msigdbr::msigdbr(species = "Homo sapiens")
        
        fluidRow(
        selectInput(
            inputId = "msigdbr_species_input",
            label = "Reference species",
            selected = "Homo sapiens",
            choices = msigdbrSpecies$Species
          ),
          selectInput(
            inputId = "msigdbr_category_input",
            label = "Select category (optional):",
            selected = "",
            choices = c("", unique(species.msig$gs_cat))
          )
        )
    })
    
    
    observeEvent(input$msigdbr_category_input, { 
      subcat <- filter(species.msig, species.msig$gs_cat == input$msigdbr_category_input)
      output$runmsigdbr_select_parameters_sub <- renderUI({
        selectInput(
            inputId = "msigdbr_subcategory_input",
            label = "Select subcategory (optional):",
            selected = "",
            choices = c("", unique(subcat$gs_subcat))
          )
    })
    })
    
    
    output$runmsigdbr_select_parameters_cont <- renderUI({
      textInput(inputId = "msigdbr_runname",
                label = "Run name",
                placeholder = "Run1")
    })

    
    eventReactive(input$runstringdb_button, {
      req(input$stringdb_select_cluster_input)
      req(input$stringdb_maxHitsToPlot_input)
      req(input$stringdb_scoreThreshold_input)
      req(input$stringdb_refSpecies_input)
      refSpeciesNum = stringdbSpecies$species_id[stringdbSpecies$compact_name == input$stringdb_refSpecies_input]

      stringRes <- runSTRINGdb(DEtable = sample_data, 
                  maxHitsToPlot = input$stringdb_maxHitsToPlot_input, 
                  refSpeciesNum = refSpeciesNum, 
                  scoreThreshold = input$stringdb_scoreThreshold_input)
      saveRDS(stringRes, paste0("SavedRuns/", input$stringdb_runname, "_string", ".rds", sep = ""))
  })
    
    eventReactive(input$runmsigdbr_button, {
      req(input$msigdbr_species_input)
      req(input$msigdbr_runname)
      
      msigdbrRes <- runMSigDB(DEtable = sample_data, species = input$msigdbr_species_input)
      saveRDS(msigdbrRes, paste0("SavedRuns/", input$msigdbr_runname, "_msigdbr", ".rds", sep = ""))
  })
    
#######################################################################################################################    
    output$stringdb_select_run_UI <- renderUI({
      if ( is.null(sample_data()$cluster) ) {
        #textOutput(NULL)
        #textOutput("enriched_pathways_by_sample_table_missing")
      } else {
        fileInput('stringdb_select_run', 'Load Run...', multiple = F, accept = c('.rds'))
      }
    })
    
    ##--------------------##
    # select cluster
    output$stringdb_select_cluster_UI <- renderUI({
      if ( is.null(sample_data()$cluster) ) {
        #textOutput(NULL)
        #textOutput("enriched_pathways_by_sample_table_missing")
      } else {
        selectInput(
          inputId = "stringdb_select_cluster_input",
          label = "Select group (or cluster)",
          choices = levels(sample_data()$cluster)
        )
      }
    })
    
    
    ##--------------------##
    # number mapped
    output$num_of_mapped <- renderValueBox({
      extract <- paste(input$stringdb_select_cluster_input, "hits", sep = "_")
        box(
          title = "Number of genes mapped",
          width = 6,
          background = "light-blue",
          sum(!is.na(string_results[[extract]]))
        )
    })
    
    output$num_of_total_genes <- renderValueBox({
      extract <- paste(input$stringdb_select_cluster_input, "hits", sep = "_")
        box(
          title = "Number of genes total",
          width = 6,
          background = "light-blue",
          length(string_results[[extract]])
        )
    })
    
    
    ##--------------------##
    # network plots
    #TODO: pval and pct.1 filter input
    output$stringdb_network <- renderPlot({
      # req(
      #   input$stringdb_select_cluster_input
      #   )

      extract <- paste(input$stringdb_select_cluster_input, "network", sep = "_")
      string_results[[extract]]
    })
    
    output$stringdb_network_png <- renderImage(deleteFile = F, {
      png_file <- paste(input$stringdb_select_cluster_input, "_network", ".png", sep = "")
      list(src = png_file, height="90%", width="90%")
      #img(src = png_file, height="60%", width="60%", align="right")
    })

    
    ##--------------------##
    # GO
    output$stringdb_GO <- renderDataTable({
      extract <- paste(input$stringdb_select_cluster_input, "GO", sep = "_")
      table <- string_results[[extract]]
      table <- table %>% dplyr::rename(
        "Term Description" = term_description,
        "Term ID" = term_id,
        "Proteins" = proteins,
        "Hits" = hits,
        "p-Value" = pvalue,
        "p-Value (adj.)" = pvalue_fdr
      ) %>% 
        dplyr::select(c("Term Description", "Term ID", "Proteins", "Hits", "p-Value (adj.)", "p-Value", dplyr::everything())) %>%
      DT::datatable(
        #table,
        filter = "bottom",
        selection = "multiple",
        escape = FALSE,
        autoHideNavigation = TRUE,
        rownames = FALSE,
        extensions = c("Buttons"),
        class = "cell-border stripe",
        options = list(
          dom = "Bfrtip",
          lengthMenu = c(15, 30, 50, 100),
          pageLength = 10,
          buttons = list(
            "colvis",
            list(
              extend = "collection",
              text = "Download/Copy",
              buttons = c("copy", "csv", "excel")
            )
          )
        )
      )
    })
    
    output$stringdb_select_GO_ann <- renderUI({
      extract <- paste(input$stringdb_select_cluster_input, "GO", sep = "_")
      selectInput(
          inputId = "stringdb_select_GO_input",
          label = NULL,
          choices = c("", levels(as.factor(string_results[[extract]][["term_id"]]))), 
          selected = NULL, 
          multiple = F
        )
    })
    
    output$stringdb_select_GO_ann_output <- renderText({
      req(input$stringdb_select_GO_input)
      extract <- paste(input$stringdb_select_cluster_input, "hits", sep = "_")
      GO_hits(GO_term = input$stringdb_select_GO_input, hits = string_results[[extract]])
      })

    # extract <- paste(input$stringdb_select_cluster_input, "hits", sep = "_")
    # reactGO_hits <- reactive(GO_hits(GO_term = input$stringdb_select_GO_input, hits = string_results[[extract]]))
    # output$stringdb_select_GO_ann_output <- renderText({
    #   observeEvent(input$stringdb_select_GO_input, {
    #     reactGO_hits()
    #   })}
    # )
    
    output$stringdb_GO_resource_info <- renderText({
      "STRING is a database of known and predicted protein-protein interactions. \n
      The interactions include direct (physical) and indirect (functional) associations; they stem from computational prediction, \n
      from knowledge transfer between organisms, and from interactions aggregated from other (primary) databases."
    })
    
    ##--------------------##
    # TODO: download entire dataset
    # KEGG
    output$stringdb_KEGG <- renderDataTable({
      extract <- paste(input$stringdb_select_cluster_input, "KEGG", sep = "_")
      table <- string_results[[extract]]
      table <- table %>% dplyr::rename(
        "Term Description" = term_description,
        "Term ID" = term_id,
        "Proteins" = proteins,
        "Hits" = hits,
        "p-Value" = pvalue,
        "p-Value (adj.)" = pvalue_fdr
      ) %>% 
        dplyr::select(c("Term Description", "Term ID", "Proteins", "Hits", "p-Value (adj.)", "p-Value", dplyr::everything())) %>%
      DT::datatable(
        #table,
        filter = "bottom",
        selection = "multiple",
        escape = FALSE,
        autoHideNavigation = TRUE,
        rownames = FALSE,
        extensions = c("Buttons"),
        class = "cell-border stripe",
        options = list(
          dom = "Bfrtip",
          lengthMenu = c(15, 30, 50, 100),
          pageLength = 10,
          buttons = list(
            "colvis",
            list(
              extend = "collection",
              text = "Download/Copy",
              buttons = c("copy", "csv", "excel")
            )
          )
        )
      )
    })


    output$msigdbr_select_run_UI <- renderUI({
      if ( is.null(sample_data()$cluster) ) {
        #textOutput(NULL)
        #textOutput("enriched_pathways_by_sample_table_missing")
      } else {
        fileInput(inputId = 'msigdbr_select_run', label = 'Load Run...', multiple = F, accept = c('.rds'))
      }
    })
    
    #MSigDBr
    ##--------------------##
    ##--------------------##
    output$msigdbr_select_cluster_UI <- renderUI({
      if ( is.null(sample_data()$cluster) ) {
        #textOutput(NULL)
        #textOutput("enriched_pathways_by_sample_table_missing")
      } else {
        selectInput(
          inputId = "msigdbr_select_cluster_input",
          label = "Select group (or cluster)",
          choices = levels(sample_data()$cluster)
        )
      }
    })
    
      
    #TODO: pval and pct.1 filter input
    output$msigdbr_select_cluster_enricher_table <- renderDataTable({
      extract <- paste(input$msigdbr_select_cluster_input, "enricher", sep = "_")
      table <- msig_results[[extract]]
      table <- table %>% dplyr::rename(
        "Term Description" = Description,
        "geneID" = geneID,
        "Hits" = Count,
        "p-Value (adj.)" = pvalue,
        "p-Value" = p.adjust,
        "q-Value" = qvalue
      ) %>% 
        dplyr::select(c("Term Description", "Hits", "p-Value (adj.)", "p-Value", "geneID", dplyr::everything())) %>% 
      DT::datatable(
        #table,
        filter = "bottom",
        selection = "multiple",
        escape = FALSE,
        autoHideNavigation = TRUE,
        rownames = FALSE,
        extensions = c("Buttons"),
        class = "cell-border stripe",
        options = list(
          dom = "Bfrtip",
          lengthMenu = c(15, 30, 50, 100),
          pageLength = 10,
          buttons = list(
            "colvis",
            list(
              extend = "collection",
              text = "Download/Copy",
              buttons = c("copy", "csv", "excel")
            )
          )
        )
      ) # %>% formatStyle( 0, target= 'row',color = 'black', backgroundColor = NULL, fontWeight = NULL, lineHeight='50%')
    })
    
    
    
    
    output$msigdbr_select_cluster_enricher_plot <- renderPlot({
      extract <- paste(input$msigdbr_select_cluster_input, "enricher_plot", sep = "_")
      msig_results[[extract]]
    })
    
    ##--------------------##
    # number mapped
    output$num_of_mapped_enricher <- renderValueBox({
      extract <- paste(input$msigdbr_select_cluster_input, "enricher", sep = "_")
        box(
          title = "Number of genes mapped",
          width = 6,
          background = "light-blue",
          str_split(noquote(msig_results[[extract]]$GeneRatio[1]), '/')[[1]][2]
        )
    })
    
    output$num_of_total_genes_enricher <- renderValueBox({
      extract <- paste(input$msigdbr_select_cluster_input, "num_genes", sep = "_")
        box(
          title = "Number of genes total",
          width = 6,
          background = "light-blue",
          msig_results[[extract]]
        )
    })
    
    output$msigdbr_enricher_select_PA_ann <- renderUI({
      extract <- paste(input$msigdbr_select_cluster_input, "enricher", sep = "_")
      selectInput(
          inputId = "msigdbr_enricher_select_PA_input",
          label = NULL,
          choices = c("", levels(as.factor(msig_results[[extract]][["ID"]]))), 
          selected = NULL, 
          multiple = F)
    })
    
    output$msigdbr_enricher_select_PA_ann_output <- renderText({
      req(input$msigdbr_enricher_select_PA_input)
      extract <- paste(input$msigdbr_select_cluster_input, "enricher", sep = "_")
      msig_results[[extract]]$geneID[msig_results[[extract]]$ID == input$msigdbr_enricher_select_PA_input]
      })
    
    output$msigdbr_select_cluster_fgsea_table <- renderDataTable({
      extract <- paste(input$msigdbr_select_cluster_input, "fgsea_results", sep = "_")
      table <- msig_results[[extract]]
      table <- table %>% dplyr::rename(
        "Term Description" = pathway,
        "Hits" = size,
        "p-Value" = pval,
        "p-Value (adj.)" = padj
      ) %>% 
        dplyr::select(c("Term Description", "Hits", "p-Value (adj.)", "p-Value", dplyr::everything())) %>% 
      DT::datatable(
        #table,
        filter = "bottom",
        selection = "multiple",
        escape = FALSE,
        autoHideNavigation = TRUE,
        rownames = FALSE,
        extensions = c("Buttons"),
        class = "cell-border stripe",
        options = list(
          dom = "Bfrtip",
          lengthMenu = c(15, 30, 50, 100),
          pageLength = 10,
          buttons = list(
            "colvis",
            list(
              extend = "collection",
              text = "Download/Copy",
              buttons = c("copy", "csv", "excel")
            )
          )
        )
      )
    })
    
    output$msigdbr_select_cluster_fgsea_gtable <- renderPlot({
      extract <- paste(input$msigdbr_select_cluster_input, "fgsea_gtable", sep = "_")
      plot(msig_results[[extract]])
    })
    
    output$david_select_cluster_UI <- renderUI({
      if ( is.null(sample_data()$cluster) ) {
        #textOutput(NULL)
        #textOutput("enriched_pathways_by_sample_table_missing")
      } else {
        selectInput(
          inputId = "david_select_cluster_input",
          label = NULL,
          choices = levels(sample_data()$cluster)
        )
      }
    })
    
    #################################################################################################################
    #################################################################################################################
    # output$fgsea_cpplots_select_cluster_dotplot_plot <- renderPlot({
    #   extract <- paste(input$msigdbr_select_cluster_input, "fgsea_results", sep = "_")
    #   extract_2 <- paste(input$msigdbr_select_cluster_input, "input_genes", sep = "_")
    #   e <- as.enrichResult(result = msig_results[[extract]], inputIds = msig_results[[extract_2]])
    #   enrichplot::dotplot(e)
    # })
    # 
    # output$fgsea_cpplots_select_cluster_emapplot_plot <- renderPlot({
    #   extract <- paste(input$msigdbr_select_cluster_input, "fgsea_results", sep = "_")
    #   extract_2 <- paste(input$msigdbr_select_cluster_input, "input_genes", sep = "_")
    #   e <- as.enrichResult(result = msig_results[[extract]], inputIds = msig_results[[extract_2]])
    #   enrichplot::emapplot(e)
    # })
    # 
    # output$fgsea_cpplots_select_cluster_cnetplot_plot <- renderPlot({
    #   extract <- paste(input$msigdbr_select_cluster_input, "fgsea_results", sep = "_")
    #   extract_2 <- paste(input$msigdbr_select_cluster_input, "input_genes", sep = "_")
    #   e <- as.enrichResult(result = msig_results[[extract]], inputIds = msig_results[[extract_2]])
    #   enrichplot::cnetplot(e)
    # })
    # 
    # output$fgsea_cpplots_select_cluster_upsetplot_plot <- renderPlot({
    #   extract <- paste(input$msigdbr_select_cluster_input, "fgsea_results", sep = "_")
    #   extract_2 <- paste(input$msigdbr_select_cluster_input, "input_genes", sep = "_")
    #   e <- as.enrichResult(result = msig_results[[extract]], inputIds = msig_results[[extract_2]])
    #   enrichplot::upsetplot(e)
    # })
    # 
    # output$fgsea_cpplots_select_cluster_heatplot_plot <- renderPlot({
    #   extract <- paste(input$msigdbr_select_cluster_input, "fgsea_results", sep = "_")
    #   extract_2 <- paste(input$msigdbr_select_cluster_input, "input_genes", sep = "_")
    #   e <- as.enrichResult(result = msig_results[[extract]], inputIds = msig_results[[extract_2]])
    #   enrichplot::heatplot(e)
    #   
    # })
    
    #makePlotSet(outputKey = 'fgsea', enrichTypeRes = msig_results, selectedCluster = input$msigdbr_select_cluster_input)
    
    #################################################################################################################
    #################################################################################################################
    output$clusterprofiler_select_run_UI <- renderUI({
      if ( is.null(sample_data()$cluster) ) {
        #textOutput(NULL)
        #textOutput("enriched_pathways_by_sample_table_missing")
      } else {
        fileInput(inputId = 'clusterprofiler_select_run', label = 'Load Run...', multiple = F, accept = c('.rds'))
      }
    })
    
    #MSigDBr
    ##--------------------##
    ##--------------------##
    output$clusterprofiler_select_cluster_UI <- renderUI({
      if ( is.null(sample_data()$cluster) ) {
        #textOutput(NULL)
        #textOutput("enriched_pathways_by_sample_table_missing")
      } else {
        selectInput(
          inputId = "clusterprofiler_select_cluster_input",
          label = "Select group (or cluster)",
          choices = levels(sample_data()$cluster)
        )
      }
    })
    
    
  }
)


```


##DONE 
obtain the complete set of gene hits per row

p-val/p-adj filtering a user-visible input.  It can have a default value, but this makes it user-editable and transparent

For the tables, it would be nice to have consistent buttons and features.  -export, possibly ‘copy to clipboard’, etc.
 
##TODO 
fgsea, genes in term

gsea ppi single plot

input really simple.  2-column table with gene and fold-change.  Ultimately - Seurat objects
 
For MSigDB, I suggest have an input at the top of the page to choose what subset is being used.

For each analysis widget, I suggest adding a short description line, with a link to the package and/or DB(s) behind it.

consistent column order, probably with the primary term (GO, pathway), # genes, pval/padj, and then datatype-specific stuff
standardize the columns

--
 making the primary term column a link to the source database.  For example, GO terms must have a website, same for msigDB, etc.

 consistent set of plots and similar table for each data source.  - make them more interactive, such as hovers.
 If the columns and structure of each type of data is made consistent, this will help share code.  -makeDotPlot()
 
 Ultimately, reports that integrate each type of data (MSigDB/enrichr, kegg, go, etc).  ?based on the set of genes per term
 integrating across data types.